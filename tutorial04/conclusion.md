## 任务
1. 实现 lept_parse_hex4()，不合法的十六进位数返回 LEPT_PARSE_INVALID_UNICODE_HEX。
2. 按第 3 节谈到的 UTF-8 编码原理，实现 lept_encode_utf8()。这函数假设码点在正确范围 U+0000 ~ U+10FFFF（用断言检测）。
3. 加入对代理对的处理，不正确的代理对范围要返回 LEPT_PARSE_INVALID_UNICODE_SURROGATE 错误。

## 总结
1. 将16进制字符串转换成16进制数，直接计算u=16*u+ch即可。这里不需要显示将u变成16进制，C语言内部进制互通，可以以任意一种形式显示、计算。
2. 套用Unicode->utf8的编码规则。假设u是16位二进制，有一些二进制的trick：
    + 如果要取u的高x位，可以u>>(16-x)。
    + 如果要取的u是某几位，比如取高x位后，只留下末y位（比如三字节的utf8的第二第三个字节）。可以先u>>(16-x)，再&一个数，这个数只有末y位是1
    + 要保留某些位常数，比如110xxxxx的前三位，可以110xxxxx | (u>>(16-x) & 0xFF),这样需要的110会得到保留。 
3. 继续做一次parse_hex4即可    
 